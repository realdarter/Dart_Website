<script>
(() => {
    const { jsPDF } = window.jspdf;

    // ==== CONFIG ====
    const HISTORY_LIMIT = 50;
    const ZOOM_MIN = 0.5;
    const ZOOM_MAX = 3;

    // ==== STATE ====
    let pdfDoc = null;
    let numPages = 0;

    let activeTool = 'select';
    let currentFontSize = 24;
    let currentFontFamily = 'sans-serif';

    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let panOffsetX = 0;
    let panOffsetY = 0;
    let currentZoom = 1;

    let hasUnsavedChanges = false;

    let arrowLine = null;
    let arrowStart = null;
    let isArrowDrawing = false;
    let activeCanvas = null;

    const fabricCanvases = new Map(); // pageNum -> fabric.Canvas

    // ==== DOM CACHE ====
    const pdfViewer = document.getElementById('pdfViewer');
    const fileInput = document.getElementById('fileInput');
    const btnLoadPdf = document.getElementById('btnLoadPdf');
    const btnSavePdf = document.getElementById('btnSavePdf');
    const fontSizeInput = document.getElementById('fontSizeInput');
    const fontFamilySelect = document.getElementById('fontFamilySelect');
    const tempMessageBox = document.getElementById('tempMessageBox');
    const initialMessage = document.getElementById('initialMessage');
    const loadingMessage = document.getElementById('loadingMessage');

    // ==== HISTORY HELPERS ====
    function ensureCanvasHistory(canvas) {
        if (!canvas.history) {
            canvas.history = [];
            canvas.historyPointer = -1;
        }
    }

    function saveCanvasState(canvas) {
        ensureCanvasHistory(canvas);

        // If we've undone some steps, drop everything after the pointer
        if (canvas.historyPointer < canvas.history.length - 1) {
            canvas.history = canvas.history.slice(0, canvas.historyPointer + 1);
        }

        canvas.history.push(
            JSON.stringify(canvas.toJSON(['annotationType', 'selectable', 'evented']))
        );
        canvas.historyPointer = canvas.history.length - 1;

        // Trim history
        if (canvas.history.length > HISTORY_LIMIT) {
            canvas.history.shift();
            canvas.historyPointer--;
        }

        if (canvas.historyPointer > 0) {
            hasUnsavedChanges = true;
        }
    }

    function restoreCanvasFromHistory(canvas) {
        if (!canvas.history || canvas.historyPointer < 0) return;

        const json = canvas.history[canvas.historyPointer];
        canvas.loadFromJSON(
            json,
            () => {
                canvas.renderAll();
                canvas.forEachObject(obj => {
                    obj.selectable = activeTool === 'select';
                    obj.evented = activeTool === 'select';
                });
            },
            (o, obj) => {
                if (o.annotationType) {
                    obj.annotationType = o.annotationType;
                }
            }
        );
    }

    function undo() {
        for (const canvas of fabricCanvases.values()) {
            if (canvas.history && canvas.historyPointer > 0) {
                canvas.historyPointer--;
                restoreCanvasFromHistory(canvas);
                showTemporaryMessage('Undo');
                return;
            }
        }
        showTemporaryMessage('Nothing to undo');
    }

    function redo() {
        for (const canvas of fabricCanvases.values()) {
            if (canvas.history && canvas.historyPointer < canvas.history.length - 1) {
                canvas.historyPointer++;
                restoreCanvasFromHistory(canvas);
                showTemporaryMessage('Redo');
                return;
            }
        }
        showTemporaryMessage('Nothing to redo');
    }

    // ==== UI HELPERS ====
    function showTemporaryMessage(message) {
        if (!tempMessageBox) return;
        tempMessageBox.textContent = message;
        tempMessageBox.style.opacity = '1';

        if (tempMessageBox._timer) clearTimeout(tempMessageBox._timer);
        tempMessageBox._timer = setTimeout(() => {
            tempMessageBox.style.opacity = '0';
        }, 3000);
    }

    function setActiveTool(tool) {
        activeTool = tool;

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.toggle('active-tool', btn.dataset.tool === tool);
        });

        const isTextTool = tool === 'text' || tool === 'select';
        fontSizeInput.disabled = !isTextTool;
        fontFamilySelect.disabled = !isTextTool;

        fabricCanvases.forEach(canvas => {
            canvas.selection = tool === 'select';
            canvas.isDrawingMode = tool === 'draw';

            if (tool === 'draw') {
                canvas.defaultCursor = 'crosshair';
            } else if (tool === 'text') {
                canvas.defaultCursor = 'text';
            } else if (tool === 'arrow') {
                canvas.defaultCursor = 'crosshair';
            } else {
                canvas.defaultCursor = 'default';
            }

            canvas.forEachObject(obj => {
                obj.selectable = tool === 'select';
                obj.evented = tool === 'select';
            });

            canvas.renderAll();
        });
    }

    function updateSelectedObjectProperties() {
        fabricCanvases.forEach(canvas => {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'i-text') {
                activeObj.set({
                    fontSize: currentFontSize,
                    fontFamily: currentFontFamily
                });
                canvas.renderAll();
                saveCanvasState(canvas);
            }
        });
    }

    // ==== ARROW HANDLERS ====
    function handleArrowStart(canvas, opt) {
        if (activeTool !== 'arrow') return;
        if (opt.target) return;

        isArrowDrawing = true;
        activeCanvas = canvas;

        const pointer = canvas.getPointer(opt.e);
        arrowStart = { x: pointer.x, y: pointer.y };

        arrowLine = new fabric.Line(
            [pointer.x, pointer.y, pointer.x, pointer.y],
            {
                strokeWidth: 3,
                fill: 'red',
                stroke: 'red',
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false
            }
        );

        canvas.add(arrowLine);
    }

    function handleArrowMove(opt) {
        if (!isArrowDrawing || !activeCanvas || !arrowLine) return;
        const pointer = activeCanvas.getPointer(opt.e);
        arrowLine.set({ x2: pointer.x, y2: pointer.y });
        activeCanvas.renderAll();
    }

    function handleArrowEnd() {
        if (!isArrowDrawing || !activeCanvas || !arrowLine) return;

        isArrowDrawing = false;

        const { x1, y1, x2, y2 } = arrowLine;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        const arrowHead = new fabric.Triangle({
            left: x2,
            top: y2,
            originX: 'center',
            originY: 'center',
            width: 15,
            height: 15,
            fill: 'red',
            stroke: 'red',
            angle: (angle * 180 / Math.PI) + 90,
            selectable: false,
            evented: false
        });

        activeCanvas.add(arrowHead);

        const group = new fabric.Group(
            [arrowLine, arrowHead],
            {
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true
            }
        );

        activeCanvas.remove(arrowLine);
        activeCanvas.remove(arrowHead);
        activeCanvas.add(group);

        activeCanvas.renderAll();
        saveCanvasState(activeCanvas);

        arrowLine = null;
        arrowStart = null;
        activeCanvas = null;
    }

    // ==== TEXT HANDLER ====
    function handleTextPlacement(canvas, opt) {
        if (activeTool !== 'text' || opt.target) return;

        const pointer = canvas.getPointer(opt.e);
        const text = new fabric.IText('', {
            left: pointer.x,
            top: pointer.y,
            fontFamily: currentFontFamily,
            fontSize: currentFontSize,
            fill: 'red',
            selectable: true,
            evented: true
        });

        canvas.add(text);
        canvas.setActiveObject(text);
        text.enterEditing();
        saveCanvasState(canvas);
    }

    // ==== PAGE RENDERING ====
    async function renderPage(pageNum) {
        try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1 });

            const maxWidth = Math.min(window.innerWidth - 100, 1400);
            const scale = maxWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            const container = document.createElement('div');
            container.className = 'pdf-page-container';
            container.style.width = `${scaledViewport.width}px`;
            container.style.height = `${scaledViewport.height}px`;
            container.dataset.pageNum = pageNum;

            const pdfCanvas = document.createElement('canvas');
            pdfCanvas.className = 'pdf-viewer-canvas';
            pdfCanvas.width = scaledViewport.width;
            pdfCanvas.height = scaledViewport.height;
            pdfCanvas.style.width = `${scaledViewport.width}px`;
            pdfCanvas.style.height = `${scaledViewport.height}px`;

            container.appendChild(pdfCanvas);
            pdfViewer.appendChild(container);

            const ctx = pdfCanvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;

            const fabricCanvasEl = document.createElement('canvas');
            fabricCanvasEl.id = `fabric-canvas-${pageNum}`;
            fabricCanvasEl.style.position = 'absolute';
            fabricCanvasEl.style.top = '0';
            fabricCanvasEl.style.left = '0';
            container.appendChild(fabricCanvasEl);

            const fabricCanvas = new fabric.Canvas(fabricCanvasEl, {
                selection: true,
                isDrawingMode: false,
                width: scaledViewport.width,
                height: scaledViewport.height
            });

            // Draw brush setup
            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
            fabricCanvas.freeDrawingBrush.color = 'red';
            fabricCanvas.freeDrawingBrush.width = 3;

            // Initialize history
            saveCanvasState(fabricCanvas);

            // Fabric events
            fabricCanvas.on('object:modified', () => saveCanvasState(fabricCanvas));
            fabricCanvas.on('object:removed', () => saveCanvasState(fabricCanvas));

            fabricCanvas.on('object:added', e => {
                // For free drawing, we capture state here; for text/arrow,
                // state is saved where they are created.
                if (activeTool === 'draw') {
                    saveCanvasState(fabricCanvas);
                }
            });

            fabricCanvas.on('path:created', e => {
                if (e.path) {
                    e.path.set({
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true
                    });
                }
                saveCanvasState(fabricCanvas);
            });

            fabricCanvas.on('mouse:down', opt => {
                const evt = opt.e;
                // Right-click: start panning
                if (evt.button === 2) {
                    isPanning = true;
                    panStartX = evt.clientX - panOffsetX;
                    panStartY = evt.clientY - panOffsetY;
                    fabricCanvas.defaultCursor = 'grabbing';
                } else {
                    if (activeTool === 'text') {
                        handleTextPlacement(fabricCanvas, opt);
                    } else if (activeTool === 'arrow') {
                        handleArrowStart(fabricCanvas, opt);
                    }
                }
            });

            fabricCanvas.on('mouse:move', opt => {
                if (isPanning) {
                    const evt = opt.e;
                    panOffsetX = evt.clientX - panStartX;
                    panOffsetY = evt.clientY - panStartY;
                    pdfViewer.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
                } else {
                    handleArrowMove(opt);
                }
            });

            fabricCanvas.on('mouse:up', () => {
                if (isPanning) {
                    isPanning = false;
                    fabricCanvas.defaultCursor = activeTool === 'draw' ? 'crosshair' :
                        activeTool === 'text' ? 'text' :
                        activeTool === 'arrow' ? 'crosshair' : 'default';
                } else {
                    handleArrowEnd();
                }
            });

            // Prevent context menu on right-click (for panning)
            container.addEventListener('contextmenu', e => e.preventDefault());

            // Delete / backspace handler for this canvas
            const deleteHandler = e => {
                if (e.key !== 'Delete' && e.key !== 'Backspace') return;

                const activeObj = fabricCanvas.getActiveObject();
                if (!activeObj) return;

                // Allow deleting grouped selection, but don't delete inside editing text
                if (activeObj.type === 'i-text' && activeObj.isEditing) return;

                if (activeObj.type === 'activeSelection') {
                    activeObj.forEachObject(obj => fabricCanvas.remove(obj));
                    fabricCanvas.discardActiveObject();
                } else {
                    fabricCanvas.remove(activeObj);
                }

                saveCanvasState(fabricCanvas);
                fabricCanvas.renderAll();
                e.preventDefault();
            };

            fabricCanvas._deleteHandler = deleteHandler;
            document.addEventListener('keydown', deleteHandler);

            fabricCanvases.set(pageNum, fabricCanvas);
            setActiveTool(activeTool); // Apply current tool to new canvas
        } catch (err) {
            console.error(`Error rendering page ${pageNum}:`, err);
        }
    }

    async function renderAllPages() {
        if (!pdfDoc) return;

        // Clear viewer
        pdfViewer.innerHTML = '';

        // Clean up old canvases and handlers
        fabricCanvases.forEach(canvas => {
            if (canvas._deleteHandler) {
                document.removeEventListener('keydown', canvas._deleteHandler);
            }
            try {
                canvas.dispose();
            } catch (e) {
                console.warn('Canvas dispose error:', e);
            }
        });
        fabricCanvases.clear();

        // Reset zoom / pan
        currentZoom = 1;
        panOffsetX = 0;
        panOffsetY = 0;
        pdfViewer.style.transform = 'translate(0,0)';

        for (let i = 1; i <= numPages; i++) {
            await renderPage(i);
        }
    }

    // ==== PDF LOAD / SAVE ====
    async function loadPDF(file) {
        if (initialMessage) initialMessage.style.display = 'none';
        if (loadingMessage) loadingMessage.style.display = 'block';

        btnSavePdf.disabled = true;

        try {
            if (pdfDoc) {
                pdfDoc.destroy();
                pdfDoc = null;
            }

            const arrayBuffer = await file.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise;
            numPages = pdfDoc.numPages;

            await renderAllPages();

            btnSavePdf.disabled = false;
            hasUnsavedChanges = false;
            showTemporaryMessage(`PDF loaded: ${numPages} page(s)`);
        } catch (e) {
            console.error('Load error:', e);
            pdfViewer.innerHTML = `<div class="text-red-600 p-8">Error: ${e.message}</div>`;
        } finally {
            if (loadingMessage) loadingMessage.style.display = 'none';
            fileInput.value = '';
        }
    }

    async function saveAllPagesAsPDF() {
        if (!numPages || !fabricCanvases.size) {
            showTemporaryMessage('Load PDF first');
            return;
        }

        btnSavePdf.disabled = true;
        btnSavePdf.textContent = 'Generating...';

        try {
            const containers = Array.from(
                document.querySelectorAll('.pdf-page-container')
            ).sort((a, b) => parseInt(a.dataset.pageNum, 10) - parseInt(b.dataset.pageNum, 10));

            const firstPage = await pdfDoc.getPage(1);
            const baseViewport = firstPage.getViewport({ scale: 1 });

            const baseWidthMm = baseViewport.width * 0.352778;
            const baseHeightMm = baseViewport.height * 0.352778;

            const doc = new jsPDF({
                orientation: baseWidthMm > baseHeightMm ? 'l' : 'p',
                unit: 'mm',
                format: [baseWidthMm, baseHeightMm]
            });

            let isFirst = true;

            for (const container of containers) {
                const pageNum = parseInt(container.dataset.pageNum, 10);
                const fabricCanvas = fabricCanvases.get(pageNum);
                const pdfCanvas = container.querySelector('.pdf-viewer-canvas');

                if (!fabricCanvas || !pdfCanvas) continue;

                const page = await pdfDoc.getPage(pageNum);
                const vp = page.getViewport({ scale: 1 });
                const pageWidthMm = vp.width * 0.352778;
                const pageHeightMm = vp.height * 0.352778;

                const mergedCanvas = document.createElement('canvas');
                mergedCanvas.width = pdfCanvas.width;
                mergedCanvas.height = pdfCanvas.height;

                const mergedCtx = mergedCanvas.getContext('2d');
                mergedCtx.drawImage(pdfCanvas, 0, 0);

                const fabricDataUrl = fabricCanvas.toDataURL({ format: 'png', multiplier: 1 });
                const fabricImage = await new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.src = fabricDataUrl;
                });

                mergedCtx.drawImage(fabricImage, 0, 0);

                const finalDataUrl = mergedCanvas.toDataURL('image/jpeg', 0.95);

                if (!isFirst) {
                    doc.addPage(
                        [pageWidthMm, pageHeightMm],
                        pageWidthMm > pageHeightMm ? 'l' : 'p'
                    );
                }

                doc.addImage(finalDataUrl, 'JPEG', 0, 0, pageWidthMm, pageHeightMm);
                isFirst = false;
            }

            doc.save('annotated_document.pdf');
            showTemporaryMessage('PDF saved!');
            hasUnsavedChanges = false;
        } catch (err) {
            console.error('Save error:', err);
            showTemporaryMessage(`Error: ${err.message}`);
        } finally {
            btnSavePdf.disabled = false;
            btnSavePdf.textContent = 'Save PDF';
        }
    }

    // ==== GLOBAL EVENTS ====
    pdfViewer.addEventListener(
        'wheel',
        e => {
            if (!e.shiftKey) return;

            e.preventDefault();

            const rect = pdfViewer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, currentZoom * delta));
            const zoomRatio = newZoom / currentZoom;

            panOffsetX = mouseX - (mouseX - panOffsetX) * zoomRatio;
            panOffsetY = mouseY - (mouseY - panOffsetY) * zoomRatio;

            currentZoom = newZoom;

            pdfViewer.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px)`;
            document
                .querySelectorAll('.pdf-page-container')
                .forEach(c => (c.style.transform = `scale(${currentZoom})`));

            showTemporaryMessage(`Zoom: ${Math.round(currentZoom * 100)}%`);
        },
        { passive: false }
    );

    document.addEventListener('keydown', e => {
        // Avoid shortcuts when typing in inputs / textareas / editing fabric text
        const target = e.target;
        const isTyping =
            target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.isContentEditable;

        let isEditingCanvasText = false;
        fabricCanvases.forEach(canvas => {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'i-text' && activeObj.isEditing) {
                isEditingCanvasText = true;
            }
        });

        if (isTyping || isEditingCanvasText) return;

        // Tools
        if (e.key === '1') {
            e.preventDefault();
            setActiveTool('draw');
        } else if (e.key === '2') {
            e.preventDefault();
            setActiveTool('arrow');
        } else if (e.key === '3') {
            e.preventDefault();
            setActiveTool('text');
        } else if (e.key === '4') {
            e.preventDefault();
            setActiveTool('select');
        }
        // Undo / Redo
        else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
        } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            redo();
        }
    });

    // Warn before closing with unsaved changes
    window.addEventListener('beforeunload', e => {
        if (!hasUnsavedChanges) return;
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    });

    // ==== BUTTONS / INPUTS ====
    btnLoadPdf.addEventListener('click', () => {
        if (hasUnsavedChanges && pdfDoc) {
            const confirmed = confirm(
                'This file has unsaved changes. Are you sure you want to replace it? All annotations will be lost.'
            );
            if (!confirmed) return;
        }
        fileInput.click();
    });

    fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;

        if (file.type === 'application/pdf') {
            loadPDF(file);
        } else {
            showTemporaryMessage('Not a PDF');
        }
    });

    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if (btn.dataset.tool) {
                setActiveTool(btn.dataset.tool);
            }
        });
    });

    btnSavePdf.addEventListener('click', saveAllPagesAsPDF);

    fontSizeInput.addEventListener('input', () => {
        currentFontSize = parseInt(fontSizeInput.value, 10) || 12;
        updateSelectedObjectProperties();
    });

    fontFamilySelect.addEventListener('change', () => {
        currentFontFamily = fontFamilySelect.value;
        updateSelectedObjectProperties();
    });

    // ==== INITIALIZE ====
    setActiveTool('select');
    currentFontSize = parseInt(fontSizeInput.value, 10) || 24;
    currentFontFamily = fontFamilySelect.value;
    fontSizeInput.disabled = true;
    fontFamilySelect.disabled = true;
})();
</script>
